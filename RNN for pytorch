'''
    简单的RNN网络用于预测的模型搭建
     created by chains
'''

import torch
from torch import nn
import numpy as np
import matplotlib.pyplot as plt
import torch.utils.data as Data
import pandas as pd
from torch.autograd import Variable
from sklearn.metrics import mean_squared_error  #均方误差
from sklearn.metrics import mean_absolute_error #平方绝对误差
from sklearn.metrics import r2_score            #R square

# 导入数据集
df = pd.read_table("D:\\科研相关\\debutanizer_data.txt", sep='\s+', header=None)     #读取txt文件的数字部分，无表头[2394,8]
data = df.values                                                                    #将其转换为numpy数组，大小为[2394,8]
data = data.astype(np.float32)
train_x = data[:2000, :7]                                                           #训练集，[2000,7]
train_y = data[:2000, 7]


test_x = data[2000:, :7]                                                            #[394,7]
test_y = data[2000:, 7]
#数据转换为torch类型
train_x = torch.from_numpy(train_x).unsqueeze(1)           #[2000,1,7],配合后面维度输入
train_y = torch.from_numpy(train_y).unsqueeze(1)           #[2000,1]
train_y = train_y.unsqueeze(1)
test_x  = torch.from_numpy(test_x).unsqueeze(1)            #[394,1,7]
test_y  = torch.from_numpy(test_y).unsqueeze(1)            #[394,1]
test_y  = test_y.unsqueeze(1)

#print(train_y.size(), test_y.size(), train_x.size(), test_x.size())   #查看数据集大小

#定义超参数，超参数还需根据自己要求进行调整
INPUT_SIZE = 7        # RNN input size
LR = 0.001             # Learning rate
Hidden_size = 32      # RNN hidden unit
num_layers = 3        # number of rnn layer
BATCH_SIZE = 50       # batch size
EPOCH = 20           # training epoch

#数据的装载
torch_dataset = Data.TensorDataset(train_x, train_y) #先将数据整理成一个DataSet类
loader = Data.DataLoader(
    dataset=torch_dataset,
    batch_size=BATCH_SIZE,
    shuffle=False,
    num_workers=2
)

#展示每个batch数据大小，以及如何实现mini-batch训练
# def show_batch():
#     for epoch in range(2):
#          for i, data in enumerate(loader):
#              inputs, label = data
#              print("epoch:", epoch, "|batch:", i, "|inputs size:", inputs.data.size(), "|label size:", label.data.size())
#
# if __name__ == '__main__':
#     show_batch()


#RNN类的定义

class RNN(nn.Module):
    def __init__(self):
        super(RNN, self).__init__()

        self.rnn = nn.RNN(
            input_size=INPUT_SIZE,
            hidden_size=Hidden_size,
            num_layers=num_layers,
            batch_first=True

        )
        self.out = nn.Linear(Hidden_size, 1)


    def forward(self, inputs, hidden_state):
        # x (batch, time_step, input_size)
        # h_state (n_layers, batch, hidden_size)
        # r_out (batch, time_step, hidden_size)
        r_out, hidden_state = self.rnn(inputs, hidden_state)

        outs = []                                            #save all predictions
        for time_step in range(r_out.size(1)):
            pred = self.out(r_out[:, time_step, :])          #size:[1,1]
            outs.append(pred)
        return torch.stack(outs, dim=1), hidden_state        #两个返回值



rnn=RNN()                                                    #模型实例化

optimizer = torch.optim.SGD(rnn.parameters(), lr=LR, momentum=0.8)
loss_func = nn.MSELoss()
hidden_state = None
#training step
if __name__ == '__main__':
    for epoch in range(EPOCH):
        for i, data_train in enumerate(loader):
            inputs, labels = data_train                                  #labels : [batch_size,1,1]
            prediction, hidden_state = rnn(inputs, hidden_state)         #prediction :[batchsize, 1, 1]
            hidden_state = hidden_state.data
            loss = loss_func(prediction, labels)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            print("epoch:", epoch, "|batch:", i, "|loss:", loss)

    #训练集的预测曲线绘制
    h_state = None
    y_real = train_y.numpy()
    train_prediction, _ = rnn(train_x, h_state)
    y_pred = train_prediction.data.numpy()
    y_pred = y_pred.flatten()
    num = np.linspace(1, len(y_real), len(y_real))
    y_real = y_real.flatten()
    print("RMSE(training dataset:):", np.sqrt(mean_squared_error(y_real, y_pred)),
          "|R2(training dataset:)", r2_score(y_real, y_pred))
    plt.plot(num, y_real, 'r-')
    plt.plot(num, y_pred, 'b-')
    plt.draw()
    plt.show()

    #测试集的预测曲线绘制
    h_state_test = None
    y_real_test = test_y.numpy().flatten()
    steps = np.linspace(1, len(y_real_test), len(y_real_test))
    y_pred_test, _ = rnn(test_x, h_state_test)
    y_pred_test = y_pred_test.data.numpy()
    y_pred_test = y_pred_test.flatten()
    print("RMSE(test dataset:):", np.sqrt(mean_squared_error(y_real_test, y_pred_test)),
          "|R2(test dataset:)", r2_score(y_real_test, y_pred_test))
    plt.plot(steps, y_real_test, 'r-')
    plt.plot(steps, y_pred_test, 'b-')
    plt.draw()
    plt.show()
